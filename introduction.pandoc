% Introduction to LambdaCube 3D


Scope
=====

LambdaCube 3D is a domain specific language for programming the GPU (graphics processing unit).
LambdaCube 3D is a Haskell-like purely functional language.

Currently LambdaCube 3D is intended for implement the part of the program which is responsible for 2D or 3D computer graphics.
Other parts of the program (e.g. networking, application logic) can be implemented in Haskell, C++ or JavaScript.
LambdaCube 3D can be used for desktop and mobile applications, either in standalone applications or in browsers too.


Related projects
================

You may want to skip this section if you have not heard of the following projects.

OpenGL
------

LambdaCube 3D is an alternative to using OpenGl.
LambdaCube 3D is functional and statically typed as opposed to OpenGl's inherently imperative style.
In any OpenGL bindings a dedicated language, the shader language should be used to implement the shaders (the GPU subprograms).
In LambdaCube 3D, shaders are implemented as regular functions.

GPipe
-----

GPipe is the most related project to LambdaCube 3D, with similar goals. The main difference is that
GPipe is a Haskell library whilst LambdaCube 3D is a standalone Haskell-like language.
See also LambdaCube 3D EDSL below.

LambdaCube 3D EDSL
------------------

LambdaCube 3D EDSL (embedded domain specific language) is a Haskell library, whilst
LambdaCube 3D DSL (abberviated as LambdaCube 3D) is a standalone Haskell-like language with its own compiler and libraries.
Currently the EDSL version is maintained and the DSL version is actively developed.
The DSL version has less syntactic noise. Other pros and cons can be found [here](http://lambdacube3d.com/questions#why-are-you-developing-a-separate-dsl-instead-of-a-haskell-edsl).

LambdaCube 3D EDSL is quite similar to GPipe. The main difference is that GPipe has more expressive power
(it supports dynamic pipelines) whilst there is more optimization opportunity in the LambdaCube 3D EDSL.

Luminance
---------

Luminance is a Haskell EDSL for GPU graphics.
In Luminance, shaders can only be implemented in the C-like shader language.


Overview
========

Basic terminology
-----------------

**Graphics engine** is the part of an application which is responsible for the GPU graphics.
LambdaCube 3D is a DSL for impelementing graphics engines.

From a purely functional point of view, the graphics engine is a pure function.
We called this function the **pipeline**.

A **frame** is the output of the pipeline.
A frame is something which can be put on the screen.

Pipelines can be composed such that the output of a pipeline becomes part of the input of another pipeline.
We will use the terminology **simple pipeline** and **composed pipeline**.

**Rendering** is the computation of one frame given the pipeline and its input.  
**Multi-pass rendering** is rendering with a composed pipeline.

A **dynamic pipeline** is a composed pipeline in which the composition depends on the pipeline input.

Currently LambdaCube 3D does not support dynamic pipelines. This limitation is planned to be lifted.
Until then a workaround is to use several pipelines and the application logic
chooses at every rendering the right pipeline depending on the input.
(If a predefined set of pipelines is not enough, it is possible to create pipelines on the fly.)

Pipeline inputs
---------------

There are limitations on possible pipeline inputs, which reflects the fact that GPUs are specialised hardware.
The current limitations are inherited from OpenGL 3.3.

The input of a simple pipeline consists of one primitive stream, zero or more uniforms and zero or more textures.

A **uniform** is a piece of data with a statically known size.
Supported uniform types are `Bool`, `Int`, `Float`, `Vec 3 Bool`, `Mat 4 4 Float`, etc.
For example, a camera position can be part of the input as a 4 dimensional `Float` matrix uniform.
The terminology 'uniform' comes from the fact that uniforms are constant values during the rendering.

A **texture** is a uniform with type `Texture`.
A `Texture` is an image with sampling configurations (discussed later).
Currently textures are treated specially in LambdadCube 3D but this is planned to be changed.

An **input stream** is a vector whose elements are **points**, **lines** or **triangles**.
A point consits of one vertex, a line consits of two vertices, and a triangle consists of three vertices.
A **vertex** is a tuple of attributes.
An **attribute** is a piece of data with a statically known size.
Supported attribute types are for example `Float`, `Bool` and tuple of supported attribute types.
A typical `Float` attribute is the x coordinate of a vertex.

Simple pipelines
----------------

Ideally, a pipeline is an arbitrary computable function which produces a frame given an input.
Unfortunately, this is not the case.
There are limitations on possible pipelines, which reflects the fact that GPUs are specialised hardware.
The current limitations are inherited from OpenGL 3.3.

The simple pipeline has only one explicit parameter, the input stream.
Uniforms and textures are implicit parameters of the pipeline; they are used as constant values in the pipeline description.

A simple pipeline is a composition of 4 special functions which are called **vertex shader**, **geometry shader**, **rasterize** and **fragment shader**:

    simple_pipeline = fragment_shader . rasterize . geometry_shader . vertex_shader

Each of these functions has a special shape.
Given these restricitons, the same pipeline can be expressed in many ways, and
it is the programmer's task to arrange the computations between these four stages. The LambdaCube 3D compiler is supposed to do some rearrangements as optimizations, though currently this is not implemented.

### Vertex shaders

Vertex shaders map vertex streams to primitive streams.

### Geometry shaders

### Rasterize functions

### Fragment shaders


Textures
--------

An **image** is a pixel rectangle, i.e. a two dimensional array of color values. A **color value** is vector of `Float`s; the vector
length should be less or equal to 4.
A **sampling configuration** is responsible for the sampling method used (discussed later).




Getting started
===============

Suppose you want to implement the graphics engine of your application in LambdaCube 3D.

-   Decide whether you want to develop for mobile or for desktop computers.  
    Supported platforms: ...
-   Decide whether your application runs in the browser or it is a standalone application.  
    Restrictions: ...
-   Choose the language of the part of your application which communicates with the graphics engine.  
    Currently Haskell, C++ and JavaScript is supported.

After making these decisions, look at a corresponding hello world program and try to modify it.

