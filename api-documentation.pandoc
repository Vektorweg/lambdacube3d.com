%LambdaCube 3D 0.3

Basic types
===========

Values
------

type        description                   example values
----------- ----------------------------- -------------------------
`Bool`      Boolean values                `True`, `False`
`Int`       signed integers               ..., `-2`, `-1`, `0`, `1`, `2`, ... 
`Word`      unsigned integers             `0`, `1`, `2`, ...
`Nat`       natural numbers               `0`, `1`, `2`, ...
                                          or `Zero`, `Succ Zero`, `Succ (Succ Zero)`, ...
`Float`     floating point numbers        `0`, `3.14`, ...
`Vec n t`   vectors                       `V3 0.1 0 0`, `V2 True False`
`Mat i j t` matrices                      `M23F (V2 0 0.1) (V2 1 1) (V3 0 0) :: Mat 2 3 Float`
----------- ----------------------------- -------------------------

The difference between `Word` and `Nat` is that they have different representation.
`Word` values are atomic, whilst `Nat` values have more structure: for example the pattern `Succ a` will
match all non-zero naturals. Usually `Nat` is used at the type level.

The vector constructors are `V2`, `V3` and `V4`.
It is only possible to construct vectors with 2, 3 or 4 dimensions.  
For example,

~~~~~ {.haskell}
    V3 0 1.1 2 :: Vec 3 Float
~~~~~

The matrix constructors are `M22F`, `M23F`, `M24F`, `M32F`, `M33F`, `M34F`, `M42F`, `M43F` and `M44F`.
The matrix constructors needs the columns of the matrices.  
For example,

~~~~~ {.haskell}
    M23F (V2 0 0.1) (V2 1 1) (V3 0 0) :: Mat 2 3 Float
~~~~~

It is only possible to construct matrices with dimensions i x j where i and j are 2, 3 or 4.  
It is only possible to construct martices of float elements.

Special types
-------------

~~~~~ {.haskell}
data PrimitiveType
    = Triangle
    | Line
    | Point
~~~~~


Basic type families
-------------------

### `VecScalar`

~~~~~ {.haskell}
VecScalar :: Nat -> Type -> Type
~~~~~

If the first argument of `VecScalar` is `1`, then the result is the second argument, otherwise `VecScalar` is the same as `Vec`.  
Examples:

~~~~~ {.haskell}
VecScalar 1 Float = Float
VecScalar 2 Float = Vec 2 Float
~~~~~

### `MatVecScalarElem`

~~~~~ {.haskell}
MatVecScalarElem :: Type -> Type
~~~~~

`MatVecScalarElem` gives back the type of elements of matrices and vectors; in case of scalars it is the identity function.  
Examples:

~~~~~ {.haskell}
MatVecScalarElem Float = Float
MatVecScalarElem (Vec 3 Bool) = Bool
MatVecScalarElem (Mat 3 3 Float) = Float
~~~~~


Basic type classes
------------------

### `Integral`

Integral numeric types are `Int` and `Word`.

### `Signed`

Signed numeric types are `Float` and `Int`.

### `Num`

Numeric types are `Float`, `Int` and `Word`.

### `Floating`

Floating numeric types are `Float`, `Float` vectors and `Float` matrices.

Utility type classes
--------------------

### `Component`

Component types are `Bool`, `Int`, `Word`, `Float` and vectors.


Stream types
============

Currently there are several stream type has its own type constructor; it is planned to use a common abstraction for them later.

~~~~~ {.haskell}
VertexStream            :: PrimitiveType ->        Type -> Type
PrimitiveStream         :: PrimitiveType -> Nat -> Type -> Type
FragmentStream          ::                  Nat -> Type -> Type
FilteredFragmentStream  ::                  Nat -> Type -> Type
ShadedFragmentStream    ::                  Nat -> Type -> Type
~~~~~

Rasterization contexts
======================

~~~~~ {.haskell}
data RasterContext :: PrimitiveType -> Type where
    TriangleCtx :: CullMode -> PolygonMode -> PolygonOffset -> ProvokingVertex -> RasterContext Triangle
    PointCtx    :: PointSize -> Float -> PointSpriteCoordOrigin                -> RasterContext Point
    LineCtx     :: Float -> ProvokingVertex                                    -> RasterContext Line

data CullMode
    = CullFront
    | CullBack
    | CullNone

data PointSize
    = PointSize Float
    | ProgramPointSize

data PolygonMode
    = PolygonFill
    | PolygonPoint PointSize
    | PolygonLine Float

data PolygonOffset
    = NoOffset
    | Offset Float Float

data PointSpriteCoordOrigin
    = LowerLeft
    | UpperLeft

data ProvokingVertex
    = LastVertex
    | FirstVertex
~~~~~

Accumulation contexts
=====================


~~~~~ {.haskell}
data FragmentOperation :: Type -> Type where
  ColorOp             :: (mask ~ VecScalar d Bool, color ~ VecScalar d c, Num c) => Blending c -> mask
                                                                   -> FragmentOperation (Color color)
  DepthOp             :: ComparisonFunction -> Bool                -> FragmentOperation (Depth Float)
  StencilOp           :: StencilTests -> StencilOps -> StencilOps  -> FragmentOperation (Stencil Int32)

data Blending :: Type -> Type where
  NoBlending          ::                                   Blending t
  BlendLogicOp        :: (Integral t) => LogicOperation -> Blending t
  Blend               :: (BlendEquation, BlendEquation)
                         -> ((BlendingFactor, BlendingFactor), (BlendingFactor, BlendingFactor))
                         -> Vec 4 Float ->                 Blending Float

data BlendingFactor
    = Zero' --- FIXME: modified
    | One
    | SrcColor
    | OneMinusSrcColor
    | DstColor
    | OneMinusDstColor
    | SrcAlpha
    | OneMinusSrcAlpha
    | DstAlpha
    | OneMinusDstAlpha
    | ConstantColor
    | OneMinusConstantColor
    | ConstantAlpha
    | OneMinusConstantAlpha
    | SrcAlphaSaturate

data BlendEquation
    = FuncAdd
    | FuncSubtract
    | FuncReverseSubtract
    | Min
    | Max

data LogicOperation
    = Clear
    | And
    | AndReverse
    | Copy
    | AndInverted
    | Noop
    | Xor
    | Or
    | Nor
    | Equiv
    | Invert
    | OrReverse
    | CopyInverted
    | OrInverted
    | Nand
    | Set

data StencilOperation
    = OpZero
    | OpKeep
    | OpReplace
    | OpIncr
    | OpIncrWrap
    | OpDecr
    | OpDecrWrap
    | OpInvert

data ComparisonFunction
    = Never
    | Less
    | Equal
    | Lequal
    | Greater
    | Notequal
    | Gequal
    | Always
~~~~~

Images
======

~~~~~ {.haskell}
data Image :: Nat -> Type -> Type where
  ColorImage          :: forall a d t color . (Num t, color ~ VecScalar d t)
                      => color  -> Image a (Color color)
  DepthImage          :: forall a . Float  -> Image a (Depth Float)
  StencilImage        :: forall a . Int    -> Image a (Stencil Int)

  -- texture support
  PrjImage            :: FrameBuffer 1 a -> Image 1 a
  PrjImageColor       :: FrameBuffer 1 (Depth Float, Color (Vec 4 Float)) -> Image 1 (Color (Vec 4 Float))
~~~~~

Textures
========

-   Texture2D
-   Sampler


Frame buffers
=============

Shaders
=======

-   Fetch
-   Transform
-   Rasterize
-   Accumulate
-   VertexOut
-   FragmentOut
-   FragmentFilter



Builtin primitive operations
----------------------------

Info for the builtin functions

  - what does it do
  - what are the valid parameters
  - give an example


###Arithmetic Functions (component-wise)
--------  ----- --------------------------------------------------  ---------
`(+)`     `::`  `Num (MatVecElem a) => a -> a -> a`                 addition of two scalar, vector or matrix
`(-)`     `::`  `Num (MatVecElem a) => a -> a -> a`                 substraction of two scalar, vector or matrix
`(*)`     `::`  `Num (MatVecElem a) => a -> a -> a`                 multiplication of two scalar, vector or matrix (component-wise)
`(/)`     `::`  `(Num t, a ~ VecScalar d t) => a -> a -> a`         division of two scalar or vector
`mod`     `::`  `(Num t, a ~ VecScalar d t) => a -> a -> a`         modulus of two scalar or vector
`neg`     `::`  `Signed (MatVecScalarElem a) => a -> a`             unary negation of a scalar, vector or matrix (component-wise)
`(+!)`    `::`  `(t ~ MatVecScalarElem a, Num t) => a -> t -> a`    addition between (scalar, vector or matrix) and a scalar
`(-!)`    `::`  `(t ~ MatVecScalarElem a, Num t) => a -> t -> a`    substraction between (scalar, vector or matrix) and a scalar
`(*!)`    `::`  `(t ~ MatVecScalarElem a, Num t) => a -> t -> a`    multiplication between (scalar, vector or matrix) and a scalar
`(/!)`    `::`  `(Num t, a ~ VecScalar d t) => a -> t -> a`         division between (scalar, vector or matrix) and a scalar
`(%!)`    `::`  `(Num t, a ~ VecScalar d t) => a -> t -> a`         modulus between (scalar, vector or matrix) and a scalar
--------  ----- --------------------------------------------------  ---------

###Geometric Functions
------------  ---                                           ---
length        (a ~ VecScalar d Float) => a -> Float         length of a vector
distance      (a ~ VecScalar d Float) => a -> a -> Float    distance of two vectors
dot           (a ~ VecScalar d Float) => a -> a -> Float    dot product
cross         (a ~ VecScalar 3 Float) => a -> a -> a        cross product
normalize     (a ~ VecScalar d Float) => a -> a             normalize a vector to have length equals to 1
faceforward   (a ~ VecScalar d Float) => a -> a -> a -> a   same as faceforward in GLSL e.g. faceForward n i nRef = if dot nRef i < 0 then n else -n
refract       (a ~ VecScalar d Float) => a -> a -> a -> a   same as refract in GLSL
reflect       (a ~ VecScalar d Float) => a -> a -> a        same as reflect in GLSL
------------

###Matrix Functions
----------  ---                                     ---
transpose   TFMat h w  -> TFMat w h                 transposes the argument matrix
det         TFMat s s  -> Float                     determinant of the argument matrix
inv         TFMat s s  -> TFMat s s                 inverse of the argument matrix
outer       w          -> h          -> TFMat h w   column vector * row vector = matrix
(.*.)       TFMat h w  -> w          -> h           matrix and vector multiplication (linear algebra)
(*.)        h          -> TFMat h w  -> w           vector and matrix multiplication (linear algebra)
(.*)        TFMat i j  -> TFMat j k  -> TFMat i k   multiplication of two matrices (linear algebra)
----------  ---

###Vector and Scalar Relational Functions (component-wise)
--------------------  ---                                                               ---
(<)                   (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   component-wise compare of x < y
(<=)                  (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   component-wise compare of x <= y
(>)                   (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   component-wise compare of x > y
(>=)                  (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   component-wise compare of x >= y
(==)                  (t ~ MatVecScalarElem a) => a -> a -> Bool                        x == y
(/=)                  (t ~ MatVecScalarElem a) => a -> a -> Bool                        x /= y
PrimEqualV            (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   x == y (component-wise)
PrimNotEqualV         (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   x /= y (component-wise)
--------------------  ---

###Logic Functions
-------   ---                                 ---
(&&)      Bool -> Bool -> Bool                logical and
(||)      Bool -> Bool -> Bool                logical or
xor       Bool -> Bool -> Bool                logical exclusive or
not       (a ~ VecScalar d Bool) => a -> a    logical negation (component-wise)
any       VecScalar d Bool -> Bool            logical or between vector components
all       VecScalar d Bool -> Bool            logical and between vector components
-------   ---

###Angle and Trigonometry Functions

The functions operate component-wise.

------  --                                       --
degrees (a ~ VecScalar d Float) => a -> a -> a   converts radians to degrees
radians (a ~ VecScalar d Float) => a -> a -> a   converts degrees to radians
acos    (a ~ VecScalar d Float) => a -> a        arc cosine
acosh   (a ~ VecScalar d Float) => a -> a        arc hyperbolic cosine
asin    (a ~ VecScalar d Float) => a -> a        arc sine
asinh   (a ~ VecScalar d Float) => a -> a        arc hyperbolic sine
atan    (a ~ VecScalar d Float) => a -> a -> a   arc tangent
atan2   (a ~ VecScalar d Float) => a -> a -> a   arc tangent
atanh   (a ~ VecScalar d Float) => a -> a -> a   arc hyperbolic tangent
cos     (a ~ VecScalar d Float) => a -> a -> a   cosine
cosh    (a ~ VecScalar d Float) => a -> a -> a   hyperbolic cosine
sin     (a ~ VecScalar d Float) => a -> a -> a   sine
sinh    (a ~ VecScalar d Float) => a -> a -> a   hyperbolic sine
tan     (a ~ VecScalar d Float) => a -> a -> a   tangent
tanh    (a ~ VecScalar d Float) => a -> a -> a   hyperbolic tangent
------  --                                       --

###Exponential Functions

The functions operate component-wise.
----------  --                                       --
exp         (a ~ VecScalar d Float) => a -> a -> a   natural exponentiation
log         (a ~ VecScalar d Float) => a -> a -> a   natural logarithm
exp2        (a ~ VecScalar d Float) => a -> a -> a   computes 2 raised to the given power
log2        (a ~ VecScalar d Float) => a -> a -> a   2 base logarithm
sqrt        (a ~ VecScalar d Float) => a -> a -> a   square root
inversesqrt (a ~ VecScalar d Float) => a -> a -> a   1 / square root
pow         (a ~ VecScalar d Float) => a -> a -> a   x raised to the y power
----------  --                                       --

###Common Functions
--------------- ----
floor           (a ~ VecScalar d Float) => a -> a                                                
PrimTrunc       (a ~ VecScalar d Float) => a -> a                                                
PrimRound       (a ~ VecScalar d Float) => a -> a                                                
PrimRoundEven   (Num t, a ~ VecScalar d t) => a -> a -> a
ceil            (Num t, a ~ VecScalar d t) => a -> a -> a                           
fract           (Num t, a ~ VecScalar d t) => a -> a -> a
min             (Num t, a ~ VecScalar d t) => a -> a -> a
max             (Num t, a ~ VecScalar d t) => a -> a -> a
PrimMinS        (Num t, a ~ VecScalar d t) => a -> t -> a
PrimMaxS        (Num t, a ~ VecScalar d t) => a -> t -> a
PrimIsNan       (a ~ VecScalar d Float, b ~ VecScalar d Bool) => a -> b
PrimIsInf       (a ~ VecScalar d Float, b ~ VecScalar d Bool) => a -> b
abs             (Signed t, a ~ VecScalar d t) => a -> a
sign            (Signed t, a ~ VecScalar d t) => a -> a
PrimModF        (a ~ VecScalar d Float) => a -> (a, a)
clamp           (Num t, a ~ VecScalar d t) => a -> a -> a -> a
clampS          (Num t, a ~ VecScalar d t) => a -> t -> t -> a
mix             (a ~ VecScalar d Float) => a -> a -> a -> a
PrimMixS        (a ~ VecScalar d Float) => a -> a -> Float -> a
PrimMixB        (a ~ VecScalar d Float, b ~ VecScalar d Bool) => a -> a -> b -> a   
step            (a ~ TFVec d Float) => a -> a -> a
PrimStepS       (a ~ VecScalar d Float) => Float -> a -> a
smoothstep      (a ~ TFVec d Float) => a -> a -> a -> a
PrimSmoothStepS (a ~ VecScalar d Float) => Float -> Float -> a -> a
--------------- ----

###Fragment Processing Functions
----------  ---
dFdx        (a ~ VecScalar d Float) => a -> a
dFdy        (a ~ VecScalar d Float) => a -> a
PrimFWidth  (a ~ VecScalar d Float) => a -> a
----------  ---

###Noise Functions
----------  ---
PrimNoise1  VecScalar d Float -> Float
PrimNoise2  VecScalar d Float -> Vec 2 Float
PrimNoise3  VecScalar d Float -> Vec 3 Float
PrimNoise4  VecScalar d Float -> Vec 4 Float
----------  ---

###Bit-wise Functions
------------- ---------------------------------------------------
PrimBAnd      (Integral t, a ~ VecScalar d t) => a -> a -> a
PrimBOr       (Integral t, a ~ VecScalar d t) => a -> a -> a
PrimBXor      (Integral t, a ~ VecScalar d t) => a -> a -> a
PrimBAndS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBOrS      (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBXorS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBAndS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBOrS      (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBXorS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBAndS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBOrS      (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBXorS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBNot      (Integral t, a ~ VecScalar d t) => a -> a
PrimBShiftL   (Integral t, a ~ VecScalar d t, b ~ VecScalar d Word) => a -> b -> a
PrimBShiftR   (Integral t, a ~ VecScalar d t, b ~ VecScalar d Word) => a -> b -> a
PrimBShiftLS  (Integral t, a ~ VecScalar d t) => a -> Word -> a
PrimBShiftRS  (Integral t, a ~ VecScalar d t) => a -> Word -> a
------------- ---------------------------------------------------

###Integer/Float Conversion Functions
-------------------   ---
PrimFloatBitsToInt    VecScalar d Float -> VecScalar d Int
PrimFloatBitsToUInt   VecScalar d Float -> VecScalar d Word
PrimIntBitsToFloat    VecScalar d Int   -> VecScalar d Float
PrimUIntBitsToFloat   VecScalar d Word  -> VecScalar d Float
-------------------   ---


Interface for inputs
====================

-   Uniform
-   TextureSlot

Interface for outputs
=====================

-   ScreenOut



