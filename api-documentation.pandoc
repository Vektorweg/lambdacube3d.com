LambdaCube 3D 0.3
===================

-   getting started: Haskell, PureScript, C++
    -   goal: collect feedback and improve the API later
    -   hint: provide screenshots of the intented result


-   overview:
    -   should introduce the purpose and features of the system
    -   should describe the relation to other systems and libraries

-   basic API documentation: should introduce the functional pipeline and corresponding primitives for the GPU model
    -   list the supported builtin primitives with type

-   homepage review:
    -   reorganize content
    -   list related publications:
        -   lambdacube related
        -   pure graphics related
        -   graphics dsl relted

Functional Pipeline Primitives
==============================
Framebuffer
-----------
-   Image
-   Framebuffer
-   ScreenOut

Rendering Parameters
--------------------
-   AccumulationContext
-   RasterContext

Shader Input
------------
-   Uniform
-   TextureSlot

Texturing
---------
-   Texture2D
-   Sampler

Shaders
-------
-   Fetch
-   Transform
-   Rasterize
-   Accumulate
-   VertexOut
-   FragmentOut
-   FragmentFilter


questions for the builtin functions:
  - what does it do
  - what are the valid parameters
  - give me an example

Builtin Primitives
==================

VecScalar _ Bool = {Bool, Vec 2 Bool, Vec 3 Bool, Vec 4 Bool}

VecScalar _ Float = {Float, Vec 2 Float, Vec 3 Float, Vec 4 Float}

Num = {Float, Int, Word}

Integral = {Int, Word}

Signed = {Float, Int}

MatVecElem = gives the component type of a vector or matrix {Float, Int, Word, Bool}

MatVecScalarElem = gives the component type of a scalar, vector or matrix {Float, Int, Word, Bool}

###Arithmetic Functions (component-wise)
--------  --------------------------------------------------  ---------
PrimAdd   Num (MatVecElem a) => a -> a -> a                   addition of two scalar, vector or matrix
PrimSub   Num (MatVecElem a) => a -> a -> a                   substraction of two scalar, vector or matrix
PrimMul   Num (MatVecElem a) => a -> a -> a                   multiplication of two scalar, vector or matrix (component-wise)
PrimDiv   (Num t, a ~ VecScalar d t) => a -> a -> a           division of two scalar or vector
PrimMod   (Num t, a ~ VecScalar d t) => a -> a -> a           modulus of two scalar or vector
PrimNeg   Signed (MatVecScalarElem a) => a -> a               unary negation of a scalar, vector or matrix (component-wise)
PrimAddS  (t ~ MatVecScalarElem a, Num t) => a -> t -> a      addition between (scalar, vector or matrix) and a scalar
PrimSubS  (t ~ MatVecScalarElem a, Num t) => a -> t -> a      substraction between (scalar, vector or matrix) and a scalar
PrimMulS  (t ~ MatVecScalarElem a, Num t) => a -> t -> a      multiplication between (scalar, vector or matrix) and a scalar
PrimDivS  (Num t, a ~ VecScalar d t) => a -> t -> a           division between (scalar, vector or matrix) and a scalar
PrimModS  (Num t, a ~ VecScalar d t) => a -> t -> a           modulus between (scalar, vector or matrix) and a scalar
--------  --------------------------------------------------  ---------

###Geometric Functions
----------------  ---                                           ---
PrimLength        (a ~ VecScalar d Float) => a -> Float         length of a vector
PrimDistance      (a ~ VecScalar d Float) => a -> a -> Float    distance of two vectors
PrimDot           (a ~ VecScalar d Float) => a -> a -> Float    dot product
PrimCross         (a ~ VecScalar 3 Float) => a -> a -> a        cross product
PrimNormalize     (a ~ VecScalar d Float) => a -> a             normalize a vector to have length equals to 1
PrimFaceForward   (a ~ VecScalar d Float) => a -> a -> a -> a   same as faceforward in GLSL e.g. faceForward n i nRef = if dot nRef i < 0 then n else -n
PrimRefract       (a ~ VecScalar d Float) => a -> a -> a -> a   same as refract in GLSL
PrimReflect       (a ~ VecScalar d Float) => a -> a -> a        same as reflect in GLSL
----------------

###Matrix Functions
----------------  ---                                     ---
PrimTranspose     TFMat h w  -> TFMat w h                 transposes the argument matrix
PrimDeterminant   TFMat s s  -> Float                     determinant of the argument matrix
PrimInverse       TFMat s s  -> TFMat s s                 inverse of the argument matrix
PrimOuterProduct  w          -> h          -> TFMat h w   column vector * row vector = matrix
PrimMulMatVec     TFMat h w  -> w          -> h           matrix and vector multiplication (linear algebra)
PrimMulVecMat     h          -> TFMat h w  -> w           vector and matrix multiplication (linear algebra)
PrimMulMatMat     TFMat i j  -> TFMat j k  -> TFMat i k   multiplication of two matrices (linear algebra)
----------------  ---

###Vector and Scalar Relational Functions (component-wise)
--------------------  ---                                                               ---
PrimLessThan          (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   component-wise compare of x < y
PrimLessThanEqual     (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   component-wise compare of x <= y
PrimGreaterThan       (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   component-wise compare of x > y
PrimGreaterThanEqual  (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   component-wise compare of x >= y
PrimEqualV            (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   x == y (component-wise)
PrimNotEqualV         (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b   x /= y (component-wise)
PrimEqual             (t ~ MatVecScalarElem a) => a -> a -> Bool                        x == y
PrimNotEqual          (t ~ MatVecScalarElem a) => a -> a -> Bool                        x /= y
--------------------  ---

###Logic Functions
-------   ---                                 ---
PrimAnd   Bool -> Bool -> Bool                logical and
PrimOr    Bool -> Bool -> Bool                logical or
PrimXor   Bool -> Bool -> Bool                logical exclusive or
PrimNot   (a ~ VecScalar d Bool) => a -> a    logical negation (component-wise)
PrimAny   VecScalar d Bool -> Bool            logical or between vector components
PrimAll   VecScalar d Bool -> Bool            logical and between vector components
-------   ---

###Angle and Trigonometry Functions

The functions operate component-wise.

----------  --                                       --
PrimDegrees (a ~ VecScalar d Float) => a -> a -> a   converts radians to degrees
PrimRadians (a ~ VecScalar d Float) => a -> a -> a   converts degrees to radians
PrimACos    (a ~ VecScalar d Float) => a -> a        arc cosine
PrimACosH   (a ~ VecScalar d Float) => a -> a        arc hyperbolic cosine
PrimASin    (a ~ VecScalar d Float) => a -> a        arc sine
PrimASinH   (a ~ VecScalar d Float) => a -> a        arc hyperbolic sine
PrimATan    (a ~ VecScalar d Float) => a -> a -> a   arc tangent
PrimATan2   (a ~ VecScalar d Float) => a -> a -> a   arc tangent
PrimATanH   (a ~ VecScalar d Float) => a -> a -> a   arc hyperbolic tangent
PrimCos     (a ~ VecScalar d Float) => a -> a -> a   cosine
PrimCosH    (a ~ VecScalar d Float) => a -> a -> a   hyperbolic cosine
PrimSin     (a ~ VecScalar d Float) => a -> a -> a   sine
PrimSinH    (a ~ VecScalar d Float) => a -> a -> a   hyperbolic sine
PrimTan     (a ~ VecScalar d Float) => a -> a -> a   tangent
PrimTanH    (a ~ VecScalar d Float) => a -> a -> a   hyperbolic tangent
----------  --                                       --

###Exponential Functions

The functions operate component-wise.
----------  --                                       --
PrimExp     (a ~ VecScalar d Float) => a -> a -> a   natural exponentiation
PrimLog     (a ~ VecScalar d Float) => a -> a -> a   natural logarithm
PrimExp2    (a ~ VecScalar d Float) => a -> a -> a   computes 2 raised to the given power
PrimLog2    (a ~ VecScalar d Float) => a -> a -> a   2 base logarithm
PrimSqrt    (a ~ VecScalar d Float) => a -> a -> a   square root
PrimInvSqrt (a ~ VecScalar d Float) => a -> a -> a   1 / square root
PrimPow     (a ~ VecScalar d Float) => a -> a -> a   x raised to the y power
----------  --                                       --

###Common Functions
--------------- ----
PrimFloor       (a ~ VecScalar d Float) => a -> a                                                
PrimTrunc       (a ~ VecScalar d Float) => a -> a                                                
PrimRound       (a ~ VecScalar d Float) => a -> a                                                
PrimRoundEven   (Num t, a ~ VecScalar d t) => a -> a -> a
PrimCeil        (Num t, a ~ VecScalar d t) => a -> a -> a                           
PrimFract       (Num t, a ~ VecScalar d t) => a -> a -> a
PrimMin         (Num t, a ~ VecScalar d t) => a -> a -> a
PrimMax         (Num t, a ~ VecScalar d t) => a -> a -> a
PrimMinS        (Num t, a ~ VecScalar d t) => a -> t -> a
PrimMaxS        (Num t, a ~ VecScalar d t) => a -> t -> a
PrimIsNan       (a ~ VecScalar d Float, b ~ VecScalar d Bool) => a -> b
PrimIsInf       (a ~ VecScalar d Float, b ~ VecScalar d Bool) => a -> b
PrimAbs         (Signed t, a ~ VecScalar d t) => a -> a
PrimSign        (Signed t, a ~ VecScalar d t) => a -> a
PrimModF        (a ~ VecScalar d Float) => a -> (a, a)
PrimClamp       (Num t, a ~ VecScalar d t) => a -> a -> a -> a
PrimClampS      (Num t, a ~ VecScalar d t) => a -> t -> t -> a
PrimMix         (a ~ VecScalar d Float) => a -> a -> a -> a
PrimMixS        (a ~ VecScalar d Float) => a -> a -> Float -> a
PrimMixB        (a ~ VecScalar d Float, b ~ VecScalar d Bool) => a -> a -> b -> a   
PrimStep        (a ~ TFVec d Float) => a -> a -> a
PrimStepS       (a ~ VecScalar d Float) => Float -> a -> a
PrimSmoothStep  (a ~ TFVec d Float) => a -> a -> a -> a
PrimSmoothStepS (a ~ VecScalar d Float) => Float -> Float -> a -> a
--------------- ----

###Fragment Processing Functions
----------  ---
PrimDFdx    (a ~ VecScalar d Float) => a -> a
PrimDFdy    (a ~ VecScalar d Float) => a -> a
PrimFWidth  (a ~ VecScalar d Float) => a -> a
----------  ---

###Noise Functions
----------  ---
PrimNoise1  VecScalar d Float -> Float
PrimNoise2  VecScalar d Float -> Vec 2 Float
PrimNoise3  VecScalar d Float -> Vec 3 Float
PrimNoise4  VecScalar d Float -> Vec 4 Float
----------  ---

###Bit-wise Functions
------------- ---------------------------------------------------
PrimBAnd      (Integral t, a ~ VecScalar d t) => a -> a -> a
PrimBOr       (Integral t, a ~ VecScalar d t) => a -> a -> a
PrimBXor      (Integral t, a ~ VecScalar d t) => a -> a -> a
PrimBAndS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBOrS      (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBXorS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBAndS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBOrS      (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBXorS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBAndS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBOrS      (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBXorS     (Integral t, a ~ VecScalar d t) => a -> t -> a
PrimBNot      (Integral t, a ~ VecScalar d t) => a -> a
PrimBShiftL   (Integral t, a ~ VecScalar d t, b ~ VecScalar d Word) => a -> b -> a
PrimBShiftR   (Integral t, a ~ VecScalar d t, b ~ VecScalar d Word) => a -> b -> a
PrimBShiftLS  (Integral t, a ~ VecScalar d t) => a -> Word -> a
PrimBShiftRS  (Integral t, a ~ VecScalar d t) => a -> Word -> a
------------- ---------------------------------------------------

###Integer/Float Conversion Functions
-------------------   ---
PrimFloatBitsToInt    VecScalar d Float -> VecScalar d Int
PrimFloatBitsToUInt   VecScalar d Float -> VecScalar d Word
PrimIntBitsToFloat    VecScalar d Int   -> VecScalar d Float
PrimUIntBitsToFloat   VecScalar d Word  -> VecScalar d Float
-------------------   ---

