%LambdaCube 3D API 0.4

We gradually improve the documentation.
If you have any question or something is confusing and needs to be clarified please
ask us via [email](introduction#contact-us) or irc on `#haskell-game` (irc.freenode.net).

Reduction phases
================

Reduction is done in three different phases:

-   Compile time CPU
-   Runtime CPU
-   Runtime GPU

The runtime CPU and runtime GPU phases are interleaved.

Design principles:

1)  Every reduction step is done in the runtime CPU phase by default.
2)  As an optimization, some reductions are done at runtime GPU instead of runtime CPU.  
    GPU operations are very slow on CPU, but the CPU implementation of GPU primitives ensures that there is
    no cheating in the types of GPU primitives.
3)  As an optimization, some reductions are done at compile time CPU instead of runtime CPU.
4)  The programmer can assert that a computation is done in a specific phase via the type system.  
    In this way, one can refactor LambdaCube 3D source code without fear of performance regressions.

Principle 1. is not yet implemented: some reductions are only possible to do at the runtime GPU phase.

Principle 4. is not implemented yet: phase information is provided in the comments, not in the types.
The compiler code generator automagically decide between the phases.


Basic types
===========

Basic values
------------

type        description                   example values
----------- ----------------------------- -------------------------
`Bool`      Boolean values                `True`, `False`
`Int`       signed integers               ..., `-2`, `-1`, `0`, `1`, `2`, ... 
`Word`      unsigned integers             `0`, `1`, `2`, ...
`Nat`       natural numbers               `0`, `1`, `2`, ...
                                          or `Zero`, `Succ Zero`, `Succ (Succ Zero)`, ...
`Float`     floating point numbers        `0`, `3.14`, ...
`Vec n t`   vectors                       `V3 0.1 0 0`, `V2 True False`
`Mat i j t` matrices                      `M23F (V2 0 0.1) (V2 1 1) (V3 0 0) :: Mat 2 3 Float`
----------- ----------------------------- -------------------------

The difference between `Word` and `Nat` is that they have different representations.
`Word` values are atomic, whilst `Nat` values have more structure: for example the pattern `Succ a`
matches all non-zero naturals. Usually `Nat` is used in types, for example, the dimension of a `Vec` is a `Nat` instead of an `Int`.

The vector constructors are `V2`, `V3` and `V4`.
It is only possible to construct vectors with 2, 3 or 4 dimensions.  
For example,

~~~~~ {.haskell}
    V3 0 1.1 2 :: Vec 3 Float
~~~~~

The matrix constructors are `M22F`, `M23F`, `M24F`, `M32F`, `M33F`, `M34F`, `M42F`, `M43F` and `M44F`.
The matrix constructors needs the columns of the matrices.  
For example,

~~~~~ {.haskell}
    M23F (V2 0 0.1) (V2 1 1) (V3 0 0) :: Mat 2 3 Float
~~~~~

It is only possible to construct matrices with dimensions i x j where i and j are 2, 3 or 4.  
It is only possible to construct martices of float elements.

Basic type families (type functions)
-------------------

~~~~~ {.haskell}
VecScalar        :: Nat -> Type -> Type
MatVecScalarElem :: Type -> Type
~~~~~

If the first argument of `VecScalar` is `1`, then the result is the second argument, otherwise `VecScalar` is the same as `Vec`.  
Examples:

~~~~~ {.haskell}
VecScalar 1 Float = Float
VecScalar 2 Float = Vec 2 Float
~~~~~

`MatVecScalarElem` gives back the type of elements of matrices and vectors; in case of scalars it is the identity function.  
Examples:

~~~~~ {.haskell}
MatVecScalarElem Float = Float
MatVecScalarElem (Vec 3 Bool) = Bool
MatVecScalarElem (Mat 3 3 Float) = Float
~~~~~


Basic type classes
------------------

type class    instances                                         description
------------- ---------------------                             --------------
`Integral`    `Int`, `Word`                                     integral numbers
`Signed`      `Float`, `Int`                                    signed numbers
`Num`         `Float`, `Int`, `Word`                            numbers
`Floating`    `Float`, `Float` vectors, `Float` matrices        floating point numbers and containers
`Component`   `Bool`, `Int`, `Word`, `Float` and its vectors    provides `zero` and `one` (see below)


Primitive operations
----------------------------

*Phase information*  
Runtime CPU: None of the primitive oparations are accessible.  
Runtime GPU: All of the primitive oparations are accessible.  
Compile time CPU: Some of the primitive oparations are accessible.  

### Values

--------  ------------------------  ---------
`zero`    `:: Component a => a`     Generic zero value, for example `zero = V3 0.0 0.0 0.0 :: Vec 3 Float`
`one`     `:: Component a => a`     Generic one value, for example `one = V3 1.0 1.0 1.0 :: Vec 3 Float`
--------  ------------------------  ---------

~~~~~ {.haskell}
rgb :: Float -> Float -> Float -> Vec 4 Float
rgb r g b = V4 r g b 1.0
~~~~~

--------- ------------------ ----------------------------
`black  ` `:: Vec 4 Float`   same as `rgb 0.0 0.0 0.0`
`gray   ` `:: Vec 4 Float`   same as `rgb 0.5 0.5 0.5`
`silver ` `:: Vec 4 Float`   same as `rgb 0.75 0.75 0.75`
`white  ` `:: Vec 4 Float`   same as `rgb 1.0 1.0 1.0`
`maroon ` `:: Vec 4 Float`   same as `rgb 0.5 0.0 0.0`
`red    ` `:: Vec 4 Float`   same as `rgb 1.0 0.0 0.0`
`olive  ` `:: Vec 4 Float`   same as `rgb 0.5 0.5 0.0`
`yellow ` `:: Vec 4 Float`   same as `rgb 1.0 1.0 0.0`
`green  ` `:: Vec 4 Float`   same as `rgb 0.0 0.5 0.0`
`lime   ` `:: Vec 4 Float`   same as `rgb 0.0 1.0 0.0`
`teal   ` `:: Vec 4 Float`   same as `rgb 0.0 0.5 0.5`
`aqua   ` `:: Vec 4 Float`   same as `rgb 0.0 1.0 1.0`
`navy   ` `:: Vec 4 Float`   same as `rgb 0.0 0.0 0.5`
`blue   ` `:: Vec 4 Float`   same as `rgb 0.0 0.0 1.0`
`purple ` `:: Vec 4 Float`   same as `rgb 0.5 0.0 0.5`
`fuchsia` `:: Vec 4 Float`   same as `rgb 1.0 0.0 1.0`
--------- ------------------ ----------------------------


### Arithmetic Functions

The functions operate component-wise.

--------  -----------------------------------------------------  ---------
`(+)`     `:: Num (MatVecElem a) => a -> a -> a`                 addition of two scalar, vector or matrix
`(-)`     `:: Num (MatVecElem a) => a -> a -> a`                 substraction of two scalar, vector or matrix
`(*)`     `:: Num (MatVecElem a) => a -> a -> a`                 multiplication of two scalar, vector or matrix
`(/)`     `:: (Num t, a ~ VecScalar d t) => a -> a -> a`         division of two scalar or vector
`mod`     `:: (Num t, a ~ VecScalar d t) => a -> a -> a`         modulus of two scalar or vector
`neg`     `:: Signed (MatVecScalarElem a) => a -> a`             unary negation of a scalar, vector or matrix
`(+!)`    `:: (t ~ MatVecScalarElem a, Num t) => a -> t -> a`    addition between (scalar, vector or matrix) and a scalar
`(-!)`    `:: (t ~ MatVecScalarElem a, Num t) => a -> t -> a`    substraction between (scalar, vector or matrix) and a scalar
`(*!)`    `:: (t ~ MatVecScalarElem a, Num t) => a -> t -> a`    multiplication between (scalar, vector or matrix) and a scalar
`(/!)`    `:: (Num t, a ~ VecScalar d t) => a -> t -> a`         division between (scalar, vector or matrix) and a scalar
`(%!)`    `:: (Num t, a ~ VecScalar d t) => a -> t -> a`         modulus between (scalar, vector or matrix) and a scalar
--------  -----------------------------------------------------  ---------

### Geometric Functions

--------------  -------------------------------------------------  ---
`length`        `:: (a ~ VecScalar d Float) => a -> Float`         length of a vector
`distance`      `:: (a ~ VecScalar d Float) => a -> a -> Float`    distance of two vectors
`dot`           `:: (a ~ VecScalar d Float) => a -> a -> Float`    dot product
`cross`         `:: (a ~ VecScalar 3 Float) => a -> a -> a`        cross product
`normalize`     `:: (a ~ VecScalar d Float) => a -> a`             normalize a vector to have length equals to 1
`faceforward`   `:: (a ~ VecScalar d Float) => a -> a -> a -> a`   same as [faceforward in GLSL](https://www.opengl.org/sdk/docs/man/html/faceforward.xhtml) e.g. `faceForward n i nRef = if dot nRef i < 0 then n else -n`
`refract`       `:: (a ~ VecScalar d Float) => a -> a -> a -> a`   same as [refract in GLSL](https://www.opengl.org/sdk/docs/man/html/refract.xhtml)
`reflect`       `:: (a ~ VecScalar d Float) => a -> a -> a`        same as [reflect in GLSL](https://www.opengl.org/sdk/docs/man/html/reflect.xhtml)
--------------

### Matrix Functions

------------  -------------------------------------------  ---
`transpose`   `:: Mat i j a  -> Mat j i a`                 transposed matrix
`det`         `:: Mat i i a  -> Float`                     determinant
`inv`         `:: Mat i i a  -> Mat i i a`                 inverse matrix
`(.*.)`       `:: Mat i j a -> Mat j k a -> Mat i k a`     matrix * matrix (multiplication in matrix algebra)
`(*.)`        `:: Mat i j a -> Vec j a   -> Vec i a`       matrix * column vector (multiplication in matrix algebra)
`(.*)`        `:: Vec i a   -> Mat i j a -> Vec j a`       row vector * matrix (multiplication in matrix algebra)
`outer`       `:: Vec j a   -> Vec i a   -> Mat i j a`     column vector * row vector (multiplication in matrix algebra)
------------

### Vector and Scalar Relational Functions (component-wise)

----------------------  --------------------------------------------------------------         ---
`(<)`                   `:: (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b`   component-wise compare of x < y
`(<=)`                  `:: (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b`   component-wise compare of x <= y
`(>)`                   `:: (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b`   component-wise compare of x > y
`(>=)`                  `:: (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b`   component-wise compare of x >= y
`(==)`                  `:: (t ~ MatVecScalarElem a) => a -> a -> Bool`                        x == y
`(/=)`                  `:: (t ~ MatVecScalarElem a) => a -> a -> Bool`                        x /= y
`PrimEqualV`            `:: (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b`   x == y (component-wise)
`PrimNotEqualV`         `:: (Num t, a ~ VecScalar d t, b ~ VecScalar d Bool) => a -> a -> b`   x /= y (component-wise)
----------------------

### Logic Functions

---------   --------                                 ---
`(&&)`      `:: Bool -> Bool -> Bool`                logical and
`(||)`      `:: Bool -> Bool -> Bool`                logical or
`xor`       `:: Bool -> Bool -> Bool`                logical exclusive or
`not`       `:: (a ~ VecScalar d Bool) => a -> a`    logical negation (component-wise)
`any`       `:: VecScalar d Bool -> Bool`            logical or between vector components
`all`       `:: VecScalar d Bool -> Bool`            logical and between vector components
---------

###Angle and Trigonometry Functions

The functions operate component-wise.

--------  -------                                       --
`degrees` `:: (a ~ VecScalar d Float) => a -> a -> a`   converts radians to degrees
`radians` `:: (a ~ VecScalar d Float) => a -> a -> a`   converts degrees to radians
`acos`    `:: (a ~ VecScalar d Float) => a -> a`        arc cosine
`acosh`   `:: (a ~ VecScalar d Float) => a -> a`        arc hyperbolic cosine
`asin`    `:: (a ~ VecScalar d Float) => a -> a`        arc sine
`asinh`   `:: (a ~ VecScalar d Float) => a -> a`        arc hyperbolic sine
`atan`    `:: (a ~ VecScalar d Float) => a -> a -> a`   arc tangent
`atan2`   `:: (a ~ VecScalar d Float) => a -> a -> a`   arc tangent
`atanh`   `:: (a ~ VecScalar d Float) => a -> a -> a`   arc hyperbolic tangent
`cos`     `:: (a ~ VecScalar d Float) => a -> a -> a`   cosine
`cosh`    `:: (a ~ VecScalar d Float) => a -> a -> a`   hyperbolic cosine
`sin`     `:: (a ~ VecScalar d Float) => a -> a -> a`   sine
`sinh`    `:: (a ~ VecScalar d Float) => a -> a -> a`   hyperbolic sine
`tan`     `:: (a ~ VecScalar d Float) => a -> a -> a`   tangent
`tanh`    `:: (a ~ VecScalar d Float) => a -> a -> a`   hyperbolic tangent
--------

###Exponential Functions

The functions operate component-wise.

------------  -------                                       --
`exp`         `:: (a ~ VecScalar d Float) => a -> a -> a`   natural exponentiation
`log`         `:: (a ~ VecScalar d Float) => a -> a -> a`   natural logarithm
`exp2`        `:: (a ~ VecScalar d Float) => a -> a -> a`   computes 2 raised to the given power
`log2`        `:: (a ~ VecScalar d Float) => a -> a -> a`   2 base logarithm
`sqrt`        `:: (a ~ VecScalar d Float) => a -> a -> a`   square root
`inversesqrt` `:: (a ~ VecScalar d Float) => a -> a -> a`   1 / square root
`pow`         `:: (a ~ VecScalar d Float) => a -> a -> a`   x raised to the y power
------------

### Common Functions

----------------- -------------------------------------------------------------     -------------------------
`floor`           `:: (a ~ VecScalar d Float) => a -> a`                            the largest integer not larger than the value (component-wise)
`trunc`           `:: (a ~ VecScalar d Float) => a -> a`                            the integer whose absolute value is largest but not larger than the absolute value of the value (component-wise)
`round`           `:: (a ~ VecScalar d Float) => a -> a`                            the nearest integer to the value (component-wise)
`roundEven`       `:: (Num t, a ~ VecScalar d t) => a -> a -> a`                    the nearest even integer to the value (component-wise)
`ceil`            `:: (Num t, a ~ VecScalar d t) => a -> a -> a`                    the smallest integer not less than the value (component-wise)
`fract`           `:: (Num t, a ~ VecScalar d t) => a -> a -> a`                    the fractional part of the value (component-wise)
`modF`            `:: (a ~ VecScalar d Float) => a -> (a, a)`                       integer and fractional components (component-wise)
`min`             `:: (Num t, a ~ VecScalar d t) => a -> a -> a`                    component-wise minimum
`max`             `:: (Num t, a ~ VecScalar d t) => a -> a -> a`                    component-wise maximum
`PrimMinS`        `:: (Num t, a ~ VecScalar d t) => a -> t -> a`                    minimum between (scalar, vector or matrix) and a scalar
`PrimMaxS`        `:: (Num t, a ~ VecScalar d t) => a -> t -> a`                    maximum between (scalar, vector or matrix) and a scalar
`isNan`           `:: (a ~ VecScalar d Float, b ~ VecScalar d Bool) => a -> b`      `True` if the value is a number (component-wise)
`isInf`           `:: (a ~ VecScalar d Float, b ~ VecScalar d Bool) => a -> b`      `True` if the value is positive or negative infinity (component-wise)
`abs`             `:: (Signed t, a ~ VecScalar d t) => a -> a`                      component-wise absolute value
`sign`            `:: (Signed t, a ~ VecScalar d t) => a -> a`                      component-wise sign
`clamp`           `:: (Num t, a ~ VecScalar d t) => a -> a -> a -> a`               constrain a value to lie between two further values (component-wise)
`clampS`          `:: (Num t, a ~ VecScalar d t) => a -> t -> t -> a`               `clamp` with scalars
`mix`             `:: (a ~ VecScalar d Float) => a -> a -> a -> a`                  linear interpolation between two values (component-wise)
`mixS`            `:: (a ~ VecScalar d Float) => a -> a -> Float -> a`              interpolate one scalar between (scalar, vector or matrix) values
`mixB`            `:: (a ~ VecScalar d Float) => a -> a -> VecScalar d Bool -> a`   `True`: select first value; `False`: select second value (component-wise)
`step`            `:: (a ~ Vec d Float) => a -> a -> a`                             step function: 0.0 if the second value is less then the first; 1.0 otherwise (component-wise)
`stepS`           `:: (a ~ VecScalar d Float) => Float -> a -> a`                   `step` with scalar
`smoothstep`      `:: (a ~ Vec d Float) => a -> a -> a -> a`                        [Hermite interpolation](https://www.opengl.org/sdk/docs/man/html/smoothstep.xhtml)  (component-wise)
`smoothstepS`     `:: (a ~ VecScalar d Float) => Float -> Float -> a -> a`          `smoothstep` with scalar
-----------------

### Fragment Processing Functions

------------  ------------------------------------- -------------------------
`dFdx`        `(a ~ VecScalar d Float) => a -> a`   [partial derivate](https://www.opengl.org/sdk/docs/man/html/dFdx.xhtml)
`dFdy`        `(a ~ VecScalar d Float) => a -> a`   [partial derivate](https://www.opengl.org/sdk/docs/man/html/dFdx.xhtml)
`fWidth`      `(a ~ VecScalar d Float) => a -> a`   [the sum of the absolute value of derivatives in x and y](https://www.opengl.org/sdk/docs/man/html/fwidth.xhtml)
------------

### Noise Functions

--------  ----------------------------------------  --------------------------
`noise1`  `:: VecScalar d Float -> Float`           [pseudo-random noise](https://www.opengl.org/sdk/docs/man4/html/noise.xhtml)
`noise2`  `:: VecScalar d Float -> Vec 2 Float`     [pseudo-random noise](https://www.opengl.org/sdk/docs/man4/html/noise.xhtml)
`noise3`  `:: VecScalar d Float -> Vec 3 Float`     [pseudo-random noise](https://www.opengl.org/sdk/docs/man4/html/noise.xhtml)
`noise4`  `:: VecScalar d Float -> Vec 4 Float`     [pseudo-random noise](https://www.opengl.org/sdk/docs/man4/html/noise.xhtml)
--------  ---

### Bit-wise Functions

The functions operate component-wise and bit-wise.

----------- --------------------------------------------------- ---------------------
`bAnd`      `:: (Integral t, a ~ VecScalar d t) => a -> a -> a` logical AND
`bOr`       `:: (Integral t, a ~ VecScalar d t) => a -> a -> a` logical OR
`bXor`      `:: (Integral t, a ~ VecScalar d t) => a -> a -> a` logical XOR
`bNot`      `:: (Integral t, a ~ VecScalar d t) => a -> a`      logical NOT
`bAndS`     `:: (Integral t, a ~ VecScalar d t) => a -> t -> a` `bAnd` with scalar
`bOrS`      `:: (Integral t, a ~ VecScalar d t) => a -> t -> a` `bOr` with scalar
`bXorS`     `:: (Integral t, a ~ VecScalar d t) => a -> t -> a` `bXor` with scalar
----------- ---------------------------------------------------

The functions operate component-wise.

---------- ---------------------------------------------------------------------------- ---------------
`shiftL`   `:: (Integral t, a ~ VecScalar d t, b ~ VecScalar d Word) => a -> b -> a`    shift left
`shiftR`   `:: (Integral t, a ~ VecScalar d t, b ~ VecScalar d Word) => a -> b -> a`    shift right
`shiftLS`  `:: (Integral t, a ~ VecScalar d t) => a -> Word -> a`                       `shiftL` with scalar
`shiftRS`  `:: (Integral t, a ~ VecScalar d t) => a -> Word -> a`                       `shiftR` with scalar
---------- ---------------------------------------------------

### Integer/Float Conversion Functions

The functions operate component-wise.

-----------------   ------------------------------------------- -----------------------
`floatBitsToInt`    `:: VecScalar d Float -> VecScalar d Int`   the encoding of a floating point value as an integer
`floatBitsToWord`   `:: VecScalar d Float -> VecScalar d Word`  the encoding of a floating point value as a word
`intBitsToFloat`    `:: VecScalar d Int   -> VecScalar d Float` inverse of `floatBitsToInt`
`wordBitsToFloat`   `:: VecScalar d Word  -> VecScalar d Float` inverse of `floatBitsToWord`
-----------------   ---


Common data structures
===============

*Phase information*  
Most of the operations of common data structures are only accessable at the compile time CPU phase.


### Homogeneous lists

`List` has the standard definition:

~~~~~ {.haskell}
data List a = Nil | Cons a (List a)
~~~~~

Lists has special syntax like in Haskell:

type                    desugared form
--------------------    ---------------------
`[a]`                   `List a`

expression              desugared form
--------------------    ---------------------
`[]`                    `Nil`
`[a]`                   `Cons a Nil`
`[a,b]`                 `Cons a (Cons b Nil)`
...                     ...

Some usual operations on lists (the definition is omitted):

~~~~~ {.haskell}
map       :: (a -> b) -> [a] -> [b]
concat    :: [[a]] -> [a]
~~~~~

*Phase information*  
`map` and `concat` is accessible in the runtime GPU phase in some context (see the `Primitive` and `Fragment` types).


### Heterogeneous lists (tuples)

~~~~~ {.haskell}
data HList :: [Type] -> Type where
    HNil :: HList '[]
    HCons :: x -> HList xs -> HList '(x: xs)
~~~~~

Examples:

~~~~~ {.haskell}
    HNil :: HList '[]
    HCons True HNil :: HList '[Bool]
    HCons 3 (HCons True HNil) :: HList '[Int, Bool]
~~~~~

Heterogeneous lists has special syntax like tuples in Haskell.  
The only difference is that LambdaCube 3D has special syntax for one element tuples too:

type                    desugared form
--------------------    ---------------------
`()`                    `HList '[]`
`((a))`                 `HList '[a]`
`(a, b)`                `HList '[a, b]`
`(a, b, c)`             `HList '[a, b, c]`
...                     ...

expression              desugared form
--------------------    ---------------------
`()`                    `HNil`
`((a))`                 `HCons a HNil`
`(a, b)`                `HCons a (HCons b HNil)`
`(a, b, c)`             `HCons a (HCons b (HCons c HNil))`
...                     ...


### `Maybe` data type

`Maybe` has the standard definition:

~~~~~ {.haskell}
data Maybe a = Nothing | Just a
~~~~~

### `Vector` data type

~~~~~ {.haskell}
data Vector (n :: Nat) t
~~~~~

A `Vector n t` is an vector with length `n`.  
The difference between `Vector` and `Vec` is that there is no restriction on the length of a `Vector`.

*Phase information*  
Currently `Vector` is an auxiliary phantom type used in the description of `Fragment`.


Special data structures
===============


### Geometric primitives

There are three type of primitives: triangles, lines and points.

~~~~~ {.haskell}
data PrimitiveType
    = Triangle
    | Line
    | Point
~~~~~

A `Primitive` value is a container of 1, 2 or 3 values tagged with a `PrimitiveType`.

~~~~~ {.haskell}
data Primitive a :: PrimitiveType -> Type where
    PrimPoint    :: a           -> Primitive a Point
    PrimLine     :: a -> a      -> Primitive a Line
    PrimTriangle :: a -> a -> a -> Primitive a Triangle
~~~~~

Basic functions on primitives:

~~~~~ {.haskell}
mapPrimitive :: (a -> b) -> Primitive a p -> Primitive b p
~~~~~

`PrimitiveStream` is a list of primitives:

~~~~~ {.haskell}
type PrimitiveStream a p = [Primitive p a]
~~~~~

Construction of `PrimitiveStream`s:

~~~~~ {.haskell}
fetchArrays :: forall a t t' . t ~ map ListElem t' => HList t' -> PrimitiveStream a (HList t)

type family ListElem a where ListElem [a] = a
~~~~~

Operations on `PrimitiveStream`s:

~~~~~ {.haskell}
mapPrimitives :: (a -> b) -> PrimitiveStream p a -> PrimitiveStream p b
mapPrimitives f = map (mapPrimitive f)
~~~~~

*Phase information*  
`mapPrimitives` is compiled to runtime GPU code.  
The other operations are not accessible in any phase.


### Fragments

A `Fragment n t` value is an `n`-vector of `Maybe (SimpleFragment t)` values.
`Maybe` is used because simple fragments may be filtered out with the `filterFragments` function (see later).

~~~~~ {.haskell}
type Fragment n t = Vector n (Maybe (SimpleFragment t))
~~~~~

Each simple fragment is a viewport coordinate with depth value and a data value.

~~~~~ {.haskell}
data SimpleFragment t = SimpleFragment
    { sFragmentCoords   :: Vec 3 Float
    , sFragmentValue    :: t
    }
~~~~~

Basic functions on fragments:

~~~~~ {.haskell}
customizeDepth :: (a -> Float) -> Fragment n a -> Fragment n a
filterFragment :: (a -> Bool)  -> Fragment n a -> Fragment n a
mapFragment    :: (a -> b)     -> Fragment n a -> Fragment n b
~~~~~

`FragmentStream` is a list of fragments:

~~~~~ {.haskell}
type FragmentStream n t  = [Fragment n t]
~~~~~

Operations on `FragmentStream`s:

~~~~~ {.haskell}
customizeDepths :: (a -> Float) -> FragmentStream n a -> FragmentStream n a
customizeDepths f = map (customizeDepth f)

filterFragments :: (a -> Bool) -> (FragmentStream n a) -> (FragmentStream n a)
filterFragments p = map (filterFragment p)

mapFragments :: (a -> b) -> FragmentStream n a -> FragmentStream n b
mapFragments f = map (mapFragment f)
~~~~~

*Phase information*  
`customizeDepths`, `filterFragments` and `mapFragments` are compiled to runtime GPU code.  
The other operations are not accessible in any phase.


### Images

An `Image n t` is `n` times a rectangle of `t`-pixels:

~~~~~ {.haskell}
type Image (n :: Nat) t = Vector n [[t]]
~~~~~

Functions which construct clear images:

~~~~~ {.haskell}
ColorImage   :: (Num t, color ~ VecScalar d t) => color  -> Image a (Color color)
DepthImage   :: Float  -> Image n (Depth Float)
StencilImage :: Int    -> Image n (Stencil Int)
~~~~~

Some wrapper functions for creating 1-layered clear images:

~~~~~ {.haskell}
emptyDepthImage = DepthImage @1
emptyColorImage = ColorImage @1
~~~~~

Other image construction functions (texture support):

~~~~~ {.haskell}
PrjImage            :: FrameBuffer 1 a -> Image 1 a
PrjImageColor       :: FrameBuffer 1 (Depth Float, Color (Vec 4 Float)) -> Image 1 (Color (Vec 4 Float))
~~~~~

*Phase information*  
`ColorImage`, `DepthImage`, `StencilImage`, `PrjImage` and `PrjImageColor` are compiled to runtime GPU code.  
The other operations are not accessible in any phase.


### Framebuffers

A `FrameBuffer n t` is an `n`-vector of images. The image types are determined by `t` (which is usually a tuple).

~~~~~ {.haskell}
data FrameBuffer (n :: Nat) t
~~~~~

TODO: document this



Rasterization
=============

Rasterization and accumulation (see below) are the two most complex operations in the API.

Rasterization basically turns a `Primitive` value into a list of `Fragment` values.  
For this, a rasterization context is needed, and also information how interpolation should be done.


### Rasterization contexts

~~~~~ {.haskell}
data RasterContext a :: PrimitiveType -> Type where
    TriangleCtx  :: CullMode -> PolygonMode a -> PolygonOffset -> ProvokingVertex -> RasterContext a Triangle
    PointCtx     :: PointSize a -> Float -> PointSpriteCoordOrigin                -> RasterContext a Point
    LineCtx      :: Float -> ProvokingVertex                                      -> RasterContext a Line

data CullMode
    = CullFront
    | CullBack
    | CullNone

data PointSize a
    = PointSize Float
    | ProgramPointSize (a -> Float)

data PolygonMode a
    = PolygonFill
    | PolygonPoint (PointSize a)
    | PolygonLine Float

data PolygonOffset
    = NoOffset
    | Offset Float Float

data PointSpriteCoordOrigin
    = LowerLeft
    | UpperLeft

data ProvokingVertex
    = LastVertex
    | FirstVertex
~~~~~

### Interpolation types

~~~~~ {.haskell}
data Interpolated t where
  Smooth        :: (Floating t) => Interpolated t   -- smooth interpolation
  NoPerspective :: (Floating t) => Interpolated t   -- no perspective correction
  Flat          ::                 Interpolated t   -- no interpolation
~~~~~

A tuple of `Interpolated` values are needed for each vertex attribute at rasterization.  
`InterpolatedType` tells what is the aggregated interpolated type:

~~~~~ {.haskell}
type family InterpolatedType a where
    InterpolatedType () = ()
    InterpolatedType (Interpolated a) = a
    InterpolatedType (Interpolated a, Interpolated b) = (a, b)
    InterpolatedType (Interpolated a, Interpolated b, Interpolated c) = (a, b, c)
~~~~~


### Rasterization contexts

TODO: explaination

~~~~~ {.haskell}
data RasterContext a :: PrimitiveType -> Type where
    TriangleCtx  :: CullMode -> PolygonMode a -> PolygonOffset -> ProvokingVertex -> RasterContext a Triangle
    PointCtx     :: PointSize a -> Float -> PointSpriteCoordOrigin                -> RasterContext a Point
    LineCtx      :: Float -> ProvokingVertex                                      -> RasterContext a Line

data CullMode
    = CullFront
    | CullBack
    | CullNone

data PointSize a
    = PointSize Float
    | ProgramPointSize (a -> Float)

data PolygonMode a
    = PolygonFill
    | PolygonPoint (PointSize a)
    | PolygonLine Float

data PolygonOffset
    = NoOffset
    | Offset Float Float

data PointSpriteCoordOrigin
    = LowerLeft
    | UpperLeft

data ProvokingVertex
    = LastVertex
    | FirstVertex
~~~~~


### The `rasterize` function

~~~~~ {.haskell}
rasterize
    :: ( b ~ InterpolatedType interpolation
       , a ~ JoinTupleType (Vec 4 Float) b )
    => interpolation                -- tuple of Smooth & Flat values
    -> RasterContext a pr
    -> Primitive a pr
    -> FragmentStream 1 b
~~~~~

TODO: more explanation

Functions built on top of `rasterize`:

~~~~~ {.haskell}
rasterizePrimitives ctx is s = concat (map (rasterize is ctx) s)
~~~~~

*Phase information*  
`rasterizePrimitives` is compiled to runtime GPU code.  
The other operations are not accessible in any phase.


Accumulation
============


###Accumulation contexts

~~~~~ {.haskell}
data FragmentOperation :: Type -> Type where
  ColorOp             :: (mask ~ VecScalar d Bool, color ~ VecScalar d c, Num c) => Blending c -> mask
                                                                   -> FragmentOperation (Color color)
  DepthOp             :: ComparisonFunction -> Bool                -> FragmentOperation (Depth Float)
  StencilOp           :: StencilTests -> StencilOps -> StencilOps  -> FragmentOperation (Stencil Int32)

data Blending :: Type -> Type where
  NoBlending          ::                                   Blending t
  BlendLogicOp        :: (Integral t) => LogicOperation -> Blending t
  Blend               :: (BlendEquation, BlendEquation)
                         -> ((BlendingFactor, BlendingFactor), (BlendingFactor, BlendingFactor))
                         -> Vec 4 Float ->                 Blending Float

data BlendingFactor
    = Zero'
    | One
    | SrcColor
    | OneMinusSrcColor
    | DstColor
    | OneMinusDstColor
    | SrcAlpha
    | OneMinusSrcAlpha
    | DstAlpha
    | OneMinusDstAlpha
    | ConstantColor
    | OneMinusConstantColor
    | ConstantAlpha
    | OneMinusConstantAlpha
    | SrcAlphaSaturate

data BlendEquation
    = FuncAdd
    | FuncSubtract
    | FuncReverseSubtract
    | Min
    | Max

data LogicOperation
    = Clear
    | And
    | AndReverse
    | Copy
    | AndInverted
    | Noop
    | Xor
    | Or
    | Nor
    | Equiv
    | Invert
    | OrReverse
    | CopyInverted
    | OrInverted
    | Nand
    | Set

data StencilOperation
    = OpZero
    | OpKeep
    | OpReplace
    | OpIncr
    | OpIncrWrap
    | OpDecr
    | OpDecrWrap
    | OpInvert

data ComparisonFunction
    = Never
    | Less
    | Equal
    | Lequal
    | Greater
    | Notequal
    | Gequal
    | Always
~~~~~

### Accumulation function

~~~~~ {.haskell}
type family ImageLC a :: Nat where ImageLC (Image n t) = n

allSame :: [a] -> Type
allSame [] = 'Unit
allSame [x] = 'Unit
allSame (x: y: xs) = 'T2 (x ~ y) (allSame (y:xs))

sameLayerCounts a = allSame (map 'ImageLC a)

remSemantics :: ImageSemantics -> Type
remSemantics (Color a) = a
remSemantics (Depth a) = a
remSemantics (Stencil a) = a

remSemantics' :: [ImageSemantics] -> [Type]
remSemantics' (Depth _: x) = map remSemantics x 
remSemantics' x = map remSemantics x 

type family FragmentOperationSem a :: ImageSemantics where FragmentOperationSem (FragmentOperation x) = x
~~~~~


~~~~~ {.haskell}
Accumulate :: forall (n :: Nat) (c :: [Type]) . (b ~ map FragmentOperationSem c) => HList c -> FragmentStream n (HList (remSemantics' b)) -> FrameBuffer n b -> FrameBuffer n b
~~~~~


~~~~~ {.haskell}
accumulateWith ctx x = (ctx, x)
overlay cl (ctx, str) = Accumulate ctx str cl
~~~~~



Interface for inputs
====================

~~~~~ {.haskell}
Uniform   :: String -> t
Attribute :: String -> t
~~~~~

~~~~~ {.haskell}
fetch       :: forall a t . String -> t -> PrimitiveStream a t
~~~~~

Interface for outputs
=====================

`Output` is an existential type which wraps a framebuffer.

~~~~~ {.haskell}
data Output where
  ScreenOut           :: FrameBuffer a b -> Output
~~~~~

~~~~~ {.haskell}
renderFrame = ScreenOut
~~~~~



